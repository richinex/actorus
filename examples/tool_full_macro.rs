//! Example: Full procedural macro functionality
//!
//! Demonstrates ALL features of the #[tool] macro:
//! 1. Struct fields with #[param] attributes (exposed to LLM)
//! 2. Config fields without #[param] (internal only)
//! 3. Required vs optional parameters
//! 4. Different parameter types (string, number, boolean)
//! 5. Custom validation logic
//! 6. Using both struct fields and args

use actorus::tool;
use actorus::tools::{Tool, ToolMetadata, ToolResult};
use actorus::{tool_result, validate_required_string};
use anyhow::Result;
use async_trait::async_trait;
use serde_json::Value;

/// A text processor with configuration fields
pub struct TextProcessorTool {
    // CONFIG FIELDS - NOT exposed to LLM
    // These control HOW the tool behaves internally
    max_length: usize,
    allow_special_chars: bool,
}

// Apply macro to generate metadata helper
// Parameters are defined in validate() and execute() from args
#[tool(
    name = "process_text",
    description = "Process text with transformations: uppercase, lowercase, reverse. Supports repeat and trim options."
)]
impl TextProcessorTool {}

impl TextProcessorTool {
    pub fn new(max_length: usize, allow_special_chars: bool) -> Self {
        Self {
            max_length,
            allow_special_chars,
        }
    }
}

#[async_trait]
impl Tool for TextProcessorTool {
    fn metadata(&self) -> ToolMetadata {
        Self::tool_metadata() // Generated by macro with #[param] fields
    }

    fn validate(&self, args: &Value) -> Result<()> {
        let text = validate_required_string!(args, "text");
        let transformation = validate_required_string!(args, "transformation");

        // Use config fields in validation
        if text.len() > self.max_length {
            return Err(anyhow::anyhow!(
                "Text length {} exceeds maximum {}",
                text.len(),
                self.max_length
            ));
        }

        if !self.allow_special_chars
            && text
                .chars()
                .any(|c| !c.is_alphanumeric() && !c.is_whitespace())
        {
            return Err(anyhow::anyhow!(
                "Special characters not allowed in this configuration"
            ));
        }

        // Validate transformation type
        if !["uppercase", "lowercase", "reverse"].contains(&transformation) {
            return Err(anyhow::anyhow!(
                "Invalid transformation '{}'. Must be: uppercase, lowercase, or reverse",
                transformation
            ));
        }

        Ok(())
    }

    async fn execute(&self, args: Value) -> Result<ToolResult> {
        self.validate(&args)?;

        let text = validate_required_string!(args, "text");
        let transformation = validate_required_string!(args, "transformation");
        let repeat = args.get("repeat").and_then(|v| v.as_i64()).unwrap_or(1) as i32;
        let trim = args.get("trim").and_then(|v| v.as_bool()).unwrap_or(false);

        let mut result = text.to_string();

        // Apply trim if requested
        if trim {
            result = result.trim().to_string();
        }

        // Apply transformation N times
        for _ in 0..repeat {
            result = match transformation {
                "uppercase" => result.to_uppercase(),
                "lowercase" => result.to_lowercase(),
                "reverse" => result.chars().rev().collect(),
                _ => unreachable!(),
            };
        }

        let message = format!(
            "Applied '{}' {} time(s) to text (trim: {}, max_length: {}, allow_special_chars: {})",
            transformation, repeat, trim, self.max_length, self.allow_special_chars
        );

        tool_result!(success: format!("{}\nResult: {}", message, result))
    }
}

/// A data validator with configuration
pub struct DataValidatorTool {
    // Config field - controls validation strictness
    strict_mode: bool,
}

// Apply macro to generate metadata helper
#[tool(
    name = "validate_data",
    description = "Validate data (email, url, number, phone) with optional length constraints"
)]
impl DataValidatorTool {}

impl DataValidatorTool {
    pub fn new(strict_mode: bool) -> Self {
        Self { strict_mode }
    }

    fn validate_email(&self, email: &str) -> bool {
        if self.strict_mode {
            // Strict validation: must have @ and . in correct positions
            email.contains('@')
                && email
                    .split('@')
                    .nth(1)
                    .map_or(false, |domain| domain.contains('.'))
        } else {
            // Lenient: just check for @
            email.contains('@')
        }
    }

    fn validate_url(&self, url: &str) -> bool {
        if self.strict_mode {
            url.starts_with("http://") || url.starts_with("https://")
        } else {
            url.contains("://") || url.contains('.')
        }
    }
}

#[async_trait]
impl Tool for DataValidatorTool {
    fn metadata(&self) -> ToolMetadata {
        Self::tool_metadata()
    }

    fn validate(&self, args: &Value) -> Result<()> {
        let _value = validate_required_string!(args, "value");
        let data_type = validate_required_string!(args, "data_type");

        if !["email", "url", "number", "phone"].contains(&data_type) {
            return Err(anyhow::anyhow!(
                "Invalid data_type '{}'. Must be: email, url, number, or phone",
                data_type
            ));
        }

        Ok(())
    }

    async fn execute(&self, args: Value) -> Result<ToolResult> {
        self.validate(&args)?;

        let value = validate_required_string!(args, "value");
        let data_type = validate_required_string!(args, "data_type");
        let min_length = args
            .get("min_length")
            .and_then(|v| v.as_i64())
            .map(|v| v as i32);
        let max_length = args
            .get("max_length")
            .and_then(|v| v.as_i64())
            .map(|v| v as i32);

        // Check length constraints
        if let Some(min) = min_length {
            if value.len() < min as usize {
                return tool_result!(failure: format!(
                    "Value length {} is less than minimum {}",
                    value.len(),
                    min
                ));
            }
        }

        if let Some(max) = max_length {
            if value.len() > max as usize {
                return tool_result!(failure: format!(
                    "Value length {} exceeds maximum {}",
                    value.len(),
                    max
                ));
            }
        }

        // Validate based on type
        let is_valid = match data_type {
            "email" => self.validate_email(value),
            "url" => self.validate_url(value),
            "number" => value.parse::<f64>().is_ok(),
            "phone" => value.chars().filter(|c| c.is_numeric()).count() >= 10,
            _ => unreachable!(),
        };

        let mode = if self.strict_mode {
            "strict"
        } else {
            "lenient"
        };

        if is_valid {
            tool_result!(success: format!(
                " Valid {} (mode: {}, length: {})",
                data_type, mode, value.len()
            ))
        } else {
            tool_result!(failure: format!(
                " Invalid {} (mode: {}, length: {})",
                data_type, mode, value.len()
            ))
        }
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    use serde_json::json;

    println!("=== Full Procedural Macro Example ===\n");
    println!("This example demonstrates:");
    println!("1. Config fields in structs (internal, NOT exposed to LLM)");
    println!("2. Parameters extracted from args in execute()");
    println!("3. Required vs optional parameter handling");
    println!("4. Different parameter types: string, number, boolean");
    println!("5. Custom validation using config fields");
    println!("6. The same tool with different configurations\n");

    // ========== TextProcessorTool Tests ==========
    println!("--- TextProcessorTool (max_length: 100, allow_special_chars: true) ---");
    let processor = TextProcessorTool::new(100, true);

    let metadata = processor.metadata();
    println!("Tool: {}", metadata.name);
    println!("Description: {}", metadata.description);
    println!("Config: max_length={}, allow_special_chars={}", 100, true);

    println!("\n--- Test 1: Basic transformation ---");
    let result = processor
        .execute(json!({
            "text": "hello world",
            "transformation": "uppercase"
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 2: Multiple transformations with trim ---");
    let result = processor
        .execute(json!({
            "text": "  hello  ",
            "transformation": "uppercase",
            "repeat": 2,
            "trim": true
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 3: Reverse transformation ---");
    let result = processor
        .execute(json!({
            "text": "stressed",
            "transformation": "reverse",
            "repeat": 1
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 4: Text exceeds max_length (config field validation) ---");
    match processor
        .execute(json!({
            "text": "a".repeat(101),
            "transformation": "lowercase"
        }))
        .await
    {
        Ok(result) if !result.success => {
            println!(" Validation caught: {}\n", result.error.unwrap());
        }
        Err(e) => {
            println!(" Validation caught: {}\n", e);
        }
        _ => println!(" Should have failed\n"),
    }

    println!("--- Test 5: Special chars not allowed (different config) ---");
    let strict_processor = TextProcessorTool::new(100, false);
    match strict_processor
        .execute(json!({
            "text": "hello@world!",
            "transformation": "uppercase"
        }))
        .await
    {
        Ok(result) if !result.success => {
            println!(" Validation caught: {}\n", result.error.unwrap());
        }
        Err(e) => {
            println!(" Validation caught: {}\n", e);
        }
        _ => println!(" Should have failed\n"),
    }

    // ========== DataValidatorTool Tests ==========
    println!("\n--- DataValidatorTool (strict_mode: true) ---");
    let validator = DataValidatorTool::new(true);

    let metadata = validator.metadata();
    println!("Tool: {}", metadata.name);
    println!("Description: {}", metadata.description);
    println!("Config: strict_mode={}", true);

    println!("\n--- Test 1: Valid email (strict mode) ---");
    let result = validator
        .execute(json!({
            "value": "user@example.com",
            "data_type": "email"
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 2: Invalid email (strict mode) ---");
    let result = validator
        .execute(json!({
            "value": "user@invalid",
            "data_type": "email"
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 3: Valid URL (strict mode) ---");
    let result = validator
        .execute(json!({
            "value": "https://example.com",
            "data_type": "url"
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 4: Length constraints ---");
    let result = validator
        .execute(json!({
            "value": "test@example.com",
            "data_type": "email",
            "min_length": 5,
            "max_length": 50
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 5: Length too short ---");
    let result = validator
        .execute(json!({
            "value": "ab",
            "data_type": "email",
            "min_length": 5
        }))
        .await?;
    println!("{}\n", result.output);

    println!("--- Test 6: Lenient mode vs strict mode ---");
    let lenient_validator = DataValidatorTool::new(false);

    println!("Strict mode:");
    let result = validator
        .execute(json!({
            "value": "user@invalid",
            "data_type": "email"
        }))
        .await?;
    println!("  {}", result.output);

    println!("Lenient mode:");
    let result = lenient_validator
        .execute(json!({
            "value": "user@invalid",
            "data_type": "email"
        }))
        .await?;
    println!("  {}\n", result.output);

    Ok(())
}
